## UPDATED CONFIG AS OF 11/6/2020
## version number 
  
############### PART 1: CAN BUS CONFIGURATION #################### 

bus_info:
  CAN:
    bus_type: socketcan   #socketcan for actual bus, vcan for virtual bus
    channel: can0         #can0 for actual bus, vcan0 for virtual bus
    bitrate: 125000       #should always be 125000

# CAN node ids
can_nodes:
  motor: 1
  tsi: 3
  pack1: 4
  pack2: 5

########## PART 2: SOFTWARE SYSTEM CONFIGUREATION ##########

emulation: True

########## PART 2A: LOGGER ##########

# a list of keys to be ignored by the logger
dont_log: ['*_raw','emulator_*']

########## PART 2B: GUI DISPLAY ##########

### list ther sensors you would like to dislay on the screen
Display:
  Pages:
  #max of 3 groups per page
    1:
      - I2C_Sensors
      - I2C_Additional
      - Motor_Controller

    2:
      - IMU_Config_Reg
      - IMU_Config_Reg2
    
    3: 
      - Motor_Controller

  Groups: 
  # max 22 sensor per 1 group
  # Try to limit # of characters for Group name to avoid wasting space on screen
    I2C_Sensors:
      - rtc_time
      - imu_temp
      - imu_calsts
      - gyro_cal
      - acc_cal
      - mag_cal
      - acc_x
      - acc_y
      - acc_z
    
    I2C_Additional:
      - linacc_x
      - linacc_y
      - linacc_z
      - angle_x
      - angle_y
      - angle_z
      - gravity_x
      - gravity_y
      - gravity_z

    IMU_Config_Reg: 
      - page_reg
      - trigger_reg
      - power_reg
      - opr_mode_reg
      - acc_config_reg
      - mag_config_reg
      - gyro_config_reg
      - acc_xoffset_lsb
      - acc_xoffset_msb
      - acc_yoffset_lsb
      - acc_yoffset_msb
      - acc_zoffset_lsb
      - acc_zoffset_msb
      - mag_xoffset_lsb
      - mag_xoffset_msb
      - mag_yoffset_lsb
      - mag_yoffset_msb
      - mag_zoffset_lsb
      - mag_zoffset_msb
      - gyro_xoffset_lsb
      - gyro_xoffset_msb
      - gyro_yoffset_lsb

    IMU_Config_Reg2:
      - gyro_zoffset_lsb
      - gyro_zoffset_msb
      - acc_raduis_lsb
      - acc_raduis_msb
      - mag_raduis_lsb
      - mag_raduis_msb
      - st_result

    Motor_Controller:
      - motor_select_application
      - motor_dc_link_circuit_voltage
      - motor_throttle_voltage
      - motor_controller_temp_over_23
      - motor_controller_temp_fahrenheit
      - motor_current_torque_actual
      - motor_current_demand
      - motor_electric_power
      - motor_warnings
      - motor_controller_temp
      - motor_digital_inputs
      - motor_velocity_actual_value
      - motor_velocity_actual_avg
      - motor_temp
      - motor_flux_actual_current
      - motor_status


      
########## PART 3: INDIVIDUAL SENSORS ##########

#Example Sensor

  #subsytem_name_data_name: #this is the sensor name
  # unit: V
  # inputs:
    #varName1: sensor1_name
    #varName2: sensor2_name             ### Note: an actual sensor would only have one cal_function
  # cal_function: "varName1 * varName2" <-- number calibration (display_variable must be boolean or number)
  # cal function:                       <-- state calibration (display_variable must be state)
    # 1: OFF
    # 2: STANDBY
    # 3: DRIVE-READY
    # 4: DRIVE
  # bus_type: I2C
  # primary_address: 0x01
  # secondary_address: [0x68,0x69]    #single hex value for CAN, list for I2C
  # precision: 2                      #number of decimal places
  # display_variable: number          #number/state/boolean
  # sample_period: 1                  #in seconds
  # bit_length: 16                    #probably don't need this
  # description: "description of the data being stored"
  
Sensor_defaults:
  unit: ''
  precision: 2                      
  display_variable: number        
  sample_period: 1                  
  bit_length: 8                  
  sample_period: 1
  description: 'This is the default description of a sensor'

IMU_Config_Constants:
  CONFIG_MODE: 0x00
  IMU_MODE: 0x08
  NDOF_MODE: 0x0C
  POWER_NORMAL: 0x00
  ACCEL_4G: 0x01
  GYRO_2000_DPS: 0x00
  MAGNETOMETER_20HZ: 0x05
 


## LIA: ADDED var_name FOR CAN SENSORS 
## Tip: Recommended max 15 characters for var_name in order to avoid cutting off data on screen 
Sensors:
#USB sensors
  # usb_torque:
  #   unit: 'Nm'
  #   inputs:
  #     Vin: usb_torque
  #   cal_function: '101.7018*Vin + 145.5199'
  #   bus_type: USB
  #   primary_address: 0x09db #vendor id
  #   secondary_address: 0x00f0 #product id
  #   #mouse
  #   # primary_address: 0x413c #vendor id
  #   # secondary_address: 0x301a #product id
  #   precision: 2
  #   display_variable: number 
  #   description: "Torque value read from USB torque sensor"
  #   bit_length: 16 #probably don't need this
  #   sample_period: 1
  #   var_name: usb_torque

#emulated sensors
  # emulator_motor_temp:
  #   unit: '°C'
  #   inputs:
  #     Tin: motor_temp 
  #   cal_function: 'Tin'
  #   bus_type: EMULATED
  #   precision: 0
  #   display_variable: number 
  #   description: "measured motor temperature"
  #   sample_period: 5   
  #   var_name:  MtrTempEm
  #   data_values: [20, 80] #number for CONSTANT, [] range for RAMP or SINE, list of values for CYCLE
  #   #note these are RAW DATA values
  #   data_pattern: RAMP #options are RAMP, SINE, CONSTANT, CYCLE (for states)
  #   data_period: 60 #period for plot shape to repeat
  
  emulator_tsi_drive_state:
    unit: ''
    inputs:
      num: emulator_tsi_drive_mode
    cal_function:
      0: 'OFF'
      1: 'DRIVE'
    bus_type: EMULATED
    precision: 0
    display_variable: state 
    description: "drive mode determined by TSI board"
    sample_period: 0.5
    var_name:  DriveStateEm
    data_values: [0, 1]
    data_pattern: CYCLE
    data_period: 30
  

  emulator_temperature:
    unit: '°C'
    inputs:
      Tin: temp
    cal_function: Tin
    bus_type: EMULATED
    precision: 0
    display_variable: number
    description: "measured motor temperature"
    sample_period: 1
    var_name:  TempEm
    data_values: [20, 80] #number for CONSTANT, [] range for RAMP or SINE, list of values for CYCLE
    data_pattern: RAMP #options are RAMP, SINE, CONSTANT, CYCLE (for states)
    data_period: 20 #period for plot shape to repeat

  emulator_sloop:
    unit: ''
    inputs:
      in: emulator_sloop
    cal_function:
      0: OPEN
      1: CLOSED
    bus_type: EMULATED
    precision: 0
    display_variable: state
    description: "measured motor temperature"
    sample_period: 1   
    var_name:  'SAFETY LOOP'
    data_values: 1 #number for CONSTANT, [] range for RAMP or SINE, list of values for CYCLE
    data_pattern: CONSTANT #options are RAMP, SINE, CONSTANT, CYCLE (for states)
    data_period: 0 #period for plot shape to repeat
    


# CAN #

  # motor_nmt_state:
  #   units: ''
  #   bus_type: CAN
  #   display_variable: string
  #   inputs:
  #     strIn: motor_nmt_state
  #   cal_function: 'strIn'
  #   primary_address: Null
  #   secondary_address: Null
  #   precision: 0
  #   description: 'This is the network state of the motor controller'
  #   sample_period: 0
  #   bit_length: 16
  #   var_name: MtrNMTState ## Name displayed on screen 

  motor_select_application:
    unit: ''
    inputs:
      in: motor_select_application
    cal_function:
      0: 'NO APP'
      1: 'APP 1 (Up to 4WD)'
    bus_type: CAN
    primary_address: 0x3000
    secondary_address: Null
    precision: 0
    display_variable: state
    description: "Used to select different applications in eDrive. Need to be in APP 1 to drive."
    bit_length: 16 #probably don't need this
    sample_period: 1
    var_name: MtrApplication

  motor_throttle_voltage:
    unit: 'mV'
    inputs:
      Vin: motor_throttle_voltage
    cal_function: 'Vin'
    bus_type: CAN
    primary_address: 0x2070
    secondary_address: 0x01
    precision: 0
    display_variable: number 
    description: "voltage measured on AD pin in mV"
    bit_length: 16 
    sample_period: 5
    var_name: MtrThrottleVltg

  
  motor_status:
    unit: ''
    inputs:
      status-enum: motor_status
    cal_function:
      # 0b0000000000000000: 'OFF'
      # 0b0000000000000001: 'READY TO SWITCH ON'
      # 0b0000000000000010: 'SWITCHED ON'
      # 0b0000000000000100: 'OPERATION ENABLED'
      # 0b0000000000001000: 'FAULT'
      0: 'OFF'
      1: 'READY TO SWITCH ON'
      2: 'SWITCHED ON'
      4: 'OPERATION ENABLED'
      8: 'FAULT'
    bus_type: CAN
    primary_address: 0x6041
    secondary_address: Null
    precision: 0
    display_variable: state 
    description: "voltage measured on AD pin in mV"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MtrStatus

  motor_flux_actual_current:
    unit: 'mA'
    inputs:
      Iin: motor_flux_actual_current
    cal_function: 'Iin'
    bus_type: CAN
    primary_address: 0x201d
    secondary_address: 0x04
    precision: 0
    display_variable: number 
    description: "positive is field weekening, value is actual field weakening current"
    bit_length: 16
    sample_period: 5
    var_name: MtrFluxCurrent
  
  motor_temp:
    unit: '°C'
    inputs:
      Tin: motor_temp 
    cal_function: 'Tin'
    bus_type: CAN
    primary_address: 0x2025
    secondary_address: Null
    precision: 0
    display_variable: number 
    description: "measured motor temperature"
    bit_length: 16 #probably don't need this
    sample_period: 5   
    var_name:  MtrTemp

  motor_velocity_actual_avg:
    unit: 'm/s'
    inputs:
      in: motor_velocity_actual_avg
    cal_function: 'in'
    bus_type: CAN
    primary_address: 0x2086
    secondary_address: Null
    precision: 2
    display_variable: number 
    description: "velocity is averaging over 1s"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MtrVelocityAvg

  motor_velocity_actual_value:
    unit: 'm/s'
    inputs:
      in: motor_velocity_actual_value
    cal_function: 'in'
    bus_type: CAN
    primary_address: 0x606c
    secondary_address: Null
    precision: 0
    display_variable: number 
    description: "Motor velocity"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MtrVelocityActual
    
  motor_digital_inputs:
    unit: ''
    inputs:
      in: motor_digital_inputs
    cal_function:
      1: 'Din1'
      2: 'Din2'
      4: 'Din3'
      8: 'Din4'
      16: 'Din5'
      32: 'Din6'
    bus_type: CAN
    primary_address: 0x2076
    secondary_address: Null
    precision: 0
    display_variable: state 
    description: ""
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MtrDigInput
    
  motor_controller_temp:
    unit: '°C'
    inputs:
      in: motor_controller_temp
    cal_function: 'in'
    bus_type: CAN
    primary_address: 0x2026
    secondary_address: 0x01
    precision: 0
    display_variable: number 
    description: "Temperature of the motor controller"
    bit_length: 8 #probably don't need this
    sample_period: 5
    var_name: mtrCntrlTemp

  motor_dc_link_circuit_voltage:
    unit: 'V'
    inputs:
      in: motor_dc_link_circuit_voltage
    cal_function: 'in/10'
    bus_type: CAN
    primary_address: 0x6079
    secondary_address: Null
    precision: 1
    display_variable: number 
    description: "Voltage of the motor controller's DC link circuit"
    bit_length: 1 #probably don't need this
    sample_period: 5
    var_name: mtr_dc_voltg
    
  motor_warnings:
    unit: ''
    inputs:
      in: motor_warnings
    cal_function:
      0: 'None'
      1: 'Controller Temp'
      2: 'Motor Temp'
      4: 'DC link under voltage'
      8: 'DC link over voltage'
      16: 'DC over current'
      32: 'Stall protection active'
      64: 'Maximum vel exceeded'
      128: 'Proposed power from BMS'
    bus_type: CAN
    primary_address: 0x2027
    secondary_address: Null
    precision: 0
    display_variable: state 
    description: "Motor Warnings"
    bit_length: 16 
    sample_period: 5
    var_name: mtr_warning
  
  motor_electric_power:
    #this is coming directly from the CAN controller
    #so it's already calculated?
    unit: 'W'
    inputs:
      in: motor_electric_power
    cal_function: 'in'
    bus_type: CAN
    primary_address: 0x2024
    secondary_address: Null
    precision: 2
    display_variable: number 
    description: "calculated DC powerconsumption"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MC_elecPwr
    
  motor_current_demand:
    unit: 'mA'
    inputs:
      Iin: motor_current_demand
    cal_function: 'Iin'
    bus_type: CAN
    primary_address: 0x201a
    secondary_address: Null
    precision: 0
    display_variable: number 
    description: "The desired value of motor current which is inserted into current regulator in units 1/1000 Motor rated current"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MC_demand

  motor_current_torque_actual:
    unit: 'A'
    inputs:
      Iin: motor_current_torque_actual
    cal_function: 'Iin'
    bus_type: CAN
    primary_address: 0x6078
    secondary_address: 0x01
    precision: 0
    display_variable: number 
    description: "Current Torque Actual Value"
    bit_length: 16 #probably don't need this
    sample_period: 5
    var_name: MC_torq_real

  motor_controller_temp_fahrenheit:
    unit: '°F'
    inputs:
      in: motor_controller_temp
    cal_function: '(in*9/5)+32'
    bus_type: VIRTUAL
    precision: 0
    display_variable: number 
    description: "Temperature of the motor controller in fahrenheit"
    bit_length: 8 #probably don't need this
    sample_period: 5
    var_name: MC_tempF
  

  motor_controller_temp_over_23:
    unit: ''
    inputs:
      in: motor_controller_temp
    conditional_cal: True
    cal_function:
      'in>=23': 'in-23'
      'True': 'in'
    bus_type: VIRTUAL
    precision: 0
    display_variable: number 
    description: "Temperature of the motor controller in fahrenheit"
    bit_length: 8 #probably don't need this
    sample_period: 5
    var_name: MC_temp>23


# I2C 
  rtc_time: 
    unit: ' '
    inputs:
      In: rtc-time
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x68
    secondary_address: [0x03,0x04,0x05,0x06,0x08,0x09]
    precision: 0
    display_variable: string  # type of data displayed on screen 
    description: "This is time"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: rtc_time  ## Name displayed on screen 

#I2C IMU REGISTER CONFIG#
  imu_temp:
    unit: '°C'
    inputs:
      In: imu_temp
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x34]
    precision: 2
    display_variable: number
    description: "IMU Temperature"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: imu_temp

  imu_calsts:
    unit: ''
    inputs:
      In: imu_calsts
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x35]
    precision: 0
    display_variable: number
    description: "IMU Calibration Status"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: imu_calsts

  # gyro_cal:
  #   unit: ''
  #   inputs:
  #     In: imu_calsts
  #   cal_function: '(In >> 4) & 0x03'
  #   bus_type: VIRTUAL 
  #   primary_address: 0x28
  #   secondary_address: 
  #   precision: 0
  #   display_variable: number
  #   description: "GYRO Calibration Status " #Needs to be 3 to be fully calibrated 
  #   bit_length: 16 #probably don't need this
  #   sample_period: 1 #sample period in seconds
  #   var_name: gyro_cal

  acc_cal:
    unit: ''
    inputs:
      In: imu_calsts
    cal_function: '(In >> 2) & 0x03'
    bus_type: VIRTUAL
    primary_address: 0x28
    secondary_address: 
    precision: 0
    display_variable: number
    description: "ACCEL Calibration Status" #Needs to be 3 to be fully calibrated 
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: acc_cal
  
  # mag_cal:
  #   unit: ''
  #   inputs:
  #     In: imu_calsts
  #   cal_function: 'In & 0x03'
  #   bus_type: VIRTUAL
  #   primary_address: 0x28
  #   secondary_address: 
  #   precision: 0
  #   display_variable: number
  #   description: "Magntometer Calibration Status" #Needs to be 3 to be fully calibrated
  #   bit_length: 16 #probably don't need this
  #   sample_period: 1 #sample period in seconds
  #   var_name: mag_cal

  acc_x:
    unit: 'm/s^2'
    inputs:
      In: acc_x
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x55,0x56]
    precision: 2
    display_variable: number
    description: "IMU Acclerometer X Vector"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: acc_x

  acc_y:
    unit: 'm/s^2'
    inputs:
      In: acc_y
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x57,0x58]
    precision: 2
    display_variable: number
    description: "IMU Acclerometer Y Vector"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: acc_y

  acc_z:
    unit: 'm/s^2'
    inputs:
      In: acc_z
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x59,0x5A]
    precision: 2
    display_variable: number
    description: "IMU Acclerometer Z Vector"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: acc_2

  linacc_x:
    unit: 'm/s^2'
    inputs:
      In: linacc_x
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x28,0x29]
    precision: 2
    display_variable: number
    description: "IMU Linear Acceleration X Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: linacc_x

  linacc_y:
    unit: 'm/s^2'
    inputs: 
      In: linacc_y 
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x2A,0x2B]
    precision: 2
    display_variable: number
    description: "IMU Linear Acceleration Y Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds  
    var_name: linacc_y

  linacc_z:
    unit: 'm/s^2'
    inputs:
      In: linacc_z
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x2C,0x2D]
    precision: 2
    display_variable: number
    description: "IMU Linear Acceleration Z Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: linacc_z

  angle_x:
    unit: '°'
    inputs:
      In: angle_x
    cal_function: 
      'In>5760': '(65536-In)*(1/16)'
      'True': 'In*(1/16)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x1A,0x1B]
    precision: 2
    display_variable: number
    description: "IMU Euler Angle X Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: angle_x

  angle_y:
    unit: '°'
    inputs:
      In: angle_y
    cal_function:
      'In>5760': '(65536-In)*(1/16)'
      'True': 'In*(1/16)'       
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x1C,0x1D]
    precision: 2
    display_variable: number
    description: "IMU Euler Angle Y Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds  
    var_name: angle_y

  angle_z:
    unit: '°'
    inputs:
      In: angle_z
    cal_function: 
      'In>5760': '(65536-In)*(1/16)'
      'True': 'In*(1/16)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x1E,0x1F]
    precision: 2
    display_variable: number
    description: "IMU Euler Angle Z Component"
    bit_length: 16 #probably don't need this
    sample_period: 1 #sample period in seconds
    var_name: angle_z

  gravity_x:
    unit: 'm/s^2'
    inputs:
      In: gravity_x
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x2E,0x2F]
    precision: 2
    display_variable: number
    description: "IMU Gravity X Component"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: grravity_x

  gravity_y:
    unit: 'm/s^2'
    inputs:
      In: gravity_y
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x30,0x31]
    precision: 2
    display_variable: number
    description: "IMU Gravity Y Component"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds  
    var_name: gravity_y

  gravity_z:
    unit: 'm/s^2'
    inputs:
      In: gravity_z
    cal_function:
      'In>1000': '(-1)*(65536-In)*(1/100)'
      'True': 'In*(1/100)'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x32,0x33]
    precision: 2
    display_variable: number
    description: "IMU Gravity Z Component"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: gravity_z

#IMU Confiuratoin Registers 

  page_reg:
    unit: ''
    inputs:
      In: page_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x07
    precision: 0
    display_variable: number
    description: "Page Register of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: page_reg

  trigger_reg:
    unit: ''
    inputs:
      In: trigger_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x3F
    precision: 0
    display_variable: number
    description: "Trigger Register of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: trigger_reg

  power_reg:
    unit: ''
    inputs:
      In: power_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x3E
    precision: 0
    display_variable: number
    description: "Page Register of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: power_reg

  opr_mode_reg:
    unit: ''
    inputs:
      In: opr_mode_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x3D
    precision: 0
    display_variable: number
    description: "Operation Range of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: opr_reg
    
  acc_config_reg:
    unit: ''
    inputs:
      In: acc_config_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x08
    precision: 0
    display_variable: number
    description: "Acceleration Config Reg of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: acc_reg

  mag_config_reg:
    unit: ''
    inputs:
      In: mag_config_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x09
    precision: 0
    display_variable: number
    description: "Magnotometer Configuration of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: mag_reg

  gyro_config_reg:
    unit: ''
    inputs:
      In: gyro_config_reg
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x0A
    precision: 0
    display_variable: number
    description: "Gyro Configuration Reg of IMU"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: gyro_reg

  acc_xoffset_lsb:
    unit: ''
    inputs:
      In: acc_xoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x55
    precision: 3
    display_variable: number
    description: "ACC x offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: acc_xos_lsb

  acc_xoffset_msb:
    unit: ''
    inputs:
      In: acc_xoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x56
    precision: 3
    display_variable: number
    description: "ACC x offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: acc_xos_msb

  acc_yoffset_lsb:
    unit: ''
    inputs:
      In: acc_yoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x57
    precision: 3
    display_variable: number
    description: "ACC y offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: acc_yos_lsb

  acc_yoffset_msb:
    unit: ''
    inputs:
      In: acc_yoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x58
    precision: 3
    display_variable: number
    description: "ACC y offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: acc_yos_msb

  acc_zoffset_lsb:
    unit: ''
    inputs:
      In: acc_zoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x59
    precision: 3
    display_variable: number
    description: "ACC z offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: acc_zos_lsb

  acc_zoffset_msb:
    unit: ''
    inputs:
      In: acc_zoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5A
    precision: 3
    display_variable: number
    description: "ACC z offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: acc_zos_msb

  mag_xoffset_lsb:
    unit: ''
    inputs:
      In: mag_xoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5B
    precision: 3
    display_variable: number
    description: "MAG x offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: mag_xos_lsb

  mag_xoffset_msb:
    unit: ''
    inputs:
      In: mag_xoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5C
    precision: 3
    display_variable: number
    description: "MAG x offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: mag_xos_msb

  mag_yoffset_lsb:
    unit: ''
    inputs:
      In: mag_yoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5D
    precision: 3
    display_variable: number
    description: "MAG y offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: mag_yos_lsb

  mag_yoffset_msb:
    unit: ''
    inputs:
      In: mag_yoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5E
    precision: 3
    display_variable: number
    description: "Mag y offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: mag_yos_msb

  mag_zoffset_lsb:
    unit: ''
    inputs:
      In: mag_zoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x5F
    precision: 3
    display_variable: number
    description: "MAG z offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: mag_zos_lsb

  mag_zoffset_msb:
    unit: ''
    inputs:
      In: mag_zoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x60
    precision: 3
    display_variable: number
    description: "Mag z offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: mag_zos_msb

  gyro_xoffset_lsb:
    unit: ''
    inputs:
      In: gyro_xoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x61
    precision: 3
    display_variable: number
    description: "Gyro x offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: gyro_xos_lsb

  gyro_xoffset_msb:
    unit: ''
    inputs:
      In: gyro_xoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x62
    precision: 3
    display_variable: number
    description: "Gyro x offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: gyro_xos_msb

  gyro_yoffset_lsb:
    unit: ''
    inputs:
      In: gyro_yoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x63
    precision: 3
    display_variable: number
    description: "Gyro y offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: gryo_yos_lsb

  gyro_yoffset_msb:
    unit: ''
    inputs:
      In: gyro_yoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x64
    precision: 3
    display_variable: number
    description: "Gyro y offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: gryo_yos_msb

  gyro_zoffset_lsb:
    unit: ''
    inputs:
      In: gyro_zoffset_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x65
    precision: 3
    display_variable: number
    description: "Gyro z offset lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: gyro_zos_lsb

  gyro_zoffset_msb:
    unit: ''
    inputs:
      In: gyro_zoffset_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: 0x66
    precision: 3
    display_variable: number
    description: "Mag z offset msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: gyro_zos_msb

  acc_raduis_lsb:
    unit: ''
    inputs:
      In: acc_raduis_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x67]
    precision: 3
    display_variable: number
    description: "Acc raduis lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: accRadLsb

  acc_raduis_msb:
    unit: ''
    inputs:
      In: acc_raduis_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x68]
    precision: 3
    display_variable: number
    description: "Acc Raduis msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: accRadMsb

  mag_raduis_lsb:
    unit: ''
    inputs:
      In: mag_raduis_lsb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x69]
    precision: 3
    display_variable: number
    description: "MAG raduis lsb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds 
    var_name: magRadLsb

  mag_raduis_msb:
    unit: ''
    inputs:
      In: mag_raduis_msb
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x6A]
    precision: 3
    display_variable: number
    description: "Acc Raduis msb for calibration"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: MagRadMsb

  st_result:
    unit: ''
    inputs:
      In: st_result
    cal_function: 'In'
    bus_type: I2C
    primary_address: 0x28
    secondary_address: [0x36]
    precision: 3
    display_variable: number
    description: "Power on self test reuslts"
    bit_length: 16 #probably don't need this
    sample_period: 0.2 #sample period in seconds
    var_name: stReslt


    #ACTUAL SENSORS LISTEDED HERE WITH BASIC FORMAT
    
        #IMU CODE SENSOR FINAL TEMPLATE BUT STILL NOT TETED WITH NEW IMU
  # imu-temp: 
  #   unit: 'C'
  #   inputs:
  #     tempIn: imu-temp
  #   cal_function: 'tempIn'
  #   bus_type: I2C
  #   primary_address: 0x29
  #   secondary_address: [0x34]
  #   precision: 2
  #   display_variable: number 
  #   description: "This is the temperature from the IMU"
  #   bit_length: 8 
  #   sample_rate: 1 #sample rate in Sec

  # imu-Accel-Data-X: #ALSO UNDERSCORE RIGHT FOR TITLES like imu_Accel_Data_X
  #   unit: 'm/s^2'
  #   inputs:
  #     AccelDataXLSB: imu-Accel-Data-X-LSB-raw ###IS THIS WAS ITS GONNA BE CALLED IN REDIS
  #     AccelDataXMSB: imu-Accel-Data-X-MSB-raw
  #   cal_function: 'AccelDataXLSB + (AccelDataXMSB << 8)' ###DOES THE SHIFTING WORK WITH EVALUATE W/ MSB AND LSB
  #   bus_type: I2C
  #   primary_address: 0x29
  #   secondary_address: [0x08, 0x09] ###MAKE SURE ORDER THE SAME AS INPUTS
  #   precision: 2
  #   display_variable: number 
  #   description: "This is the Acceleration of X Axis from the IMU"
  #   bit_length: 8 
  #   sample_rate: 1 #sample rate in Hz

  # imu-Accel-Data-Y:
  #   unit: 'm/s^2'
  #   inputs:
  #     AccelDataYLSB: imu-Accel-Data-Y-LSB-raw
  #     AccelDataYMSB: imu-Accel-Data-Y-MSB-raw
  #   cal_function: 'AccelDataYLSB + (AccelDataYMSB << 8)'
  #   bus_type: I2C
  #   primary_address: 0x29
  #   secondary_address: [0x0A, 0x0B]
  #   precision: 2
  #   display_variable: number 
  #   description: "This is the Acceleration of Y Axis from the IMU"
  #   bit_length: 8 
  #   sample_rate: 1 #sample rate in Hz

  # imu-Accel-Data-Z:
  #   unit: 'm/s^2'
  #   inputs:
  #     AccelDataZLSB: imu-Accel-Data-Z-LSB-raw
  #     AccelDataZMSB: imu-Accel-Data-Z-MSB-raw
  #   cal_function: 'AccelDataZLSB + (AccelDataZMSB << 8)'
  #   bus_type: I2C
  #   primary_address: 0x29
  #   secondary_address: [0x0C, 0x0D]
  #   precision: 2
  #   display_variable: number 
  #   description: "This is the Acceleration of Z Axis from the IMU"
  #   bit_length: 8 
  #   sample_rate: 1 #sample rate in Hz


 



################## WATCHER STUFF ##########################

##Example Control
#TSI-Heat_Check:
    #cooldown: 10                                      #minimum time between activating (seconds)
    #max_duration: 30                           #time after which it will automatically turn off
    #inputs:
        #Tempin: TSI-Temp 
    #entry_condition:
        #str: 'Tempin > 60'
        #type: REPETITION                         #REPETITION or PERIOD or INSTANTANEOUS
        #reps: 5
        #duration: 10                       #Repetitions-Seconds for REPETITION and Seconds for DURATION; INSTANTANEOUS does not use this field
    #exit_condition:
        #str: 'Tempin <= 40'                     #Condition to turn off Watcher action once its been activated, only used for LATCH persistence, cannot be true at same time as Condition
        #type: DURATION
        #duration: 8
    #action:
        #type: LOG                                  #if LOG put text, if WARNING put text (maybe color/flashing?), if WRITE write to a sensor on the vehicle:
        #message: 'TSI Temperature over 60'  

    #NOTE: these are not full configurations. Just examples of Action_Details for alternate Action_Type's

    #action:
        # type: WARNING
        # message: "msg1"
        # suggestion: "suggestion1"
        # priority: 5

    #action:
        # type: WRITE
        # sensor: sensorName
        # value: val

Controls:

## Watcher Sensor 
# IMU_gravityZ:
#     cooldown: 10                                      #minimum time between activating (seconds)
#     max_duration: 30                           #time after which it will automatically turn off
#     inputs:
#         grav: gravity_z 
#     entry_condition:
#         str: 'grav < 5'
#         type: INSTANTANEOUS                         #REPETITION or PERIOD or INSTANTANEOUS                    
#     exit_condition:
#         str: 'grav > 8'                     #Condition to turn off Watcher action once its been activated, only used for LATCH persistence, cannot be true at same time as Condition
#         type: INSTANTANEOUS
#     action:
#         type: WARNING                                  #if LOG put text, if WARNING put text (maybe color/flashing?), if WRITE write to a sensor on the vehicle:
#         message: "gravity under 5 "
#         suggestion: "level out"
#         priority: 1

  mtr_selct_app:
    cooldown: 10                                      #minimum time between activating (seconds)
    max_duration: 30                           #time after which it will automatically turn off
    inputs:
        state: emulator_tsi_drive_state
    entry_condition:
        str: 'state == "DRIVE"'
        type: INSTANTANEOUS                         #REPETITION or PERIOD or INSTANTANEOUS                    
    exit_condition:
        str: 'state == "OFF"'                     #Condition to turn off Watcher action once its been activated, only used for LATCH persistence, cannot be true at same time as Condition
        type: INSTANTANEOUS
    action:
        type: WRITE                                  #if LOG put text, if WARNING put text (maybe color/flashing?), if WRITE write to a sensor on the vehicle:
        sensor: motor_select_application
        value: 1


  # Emulated-Temp_Check:
  #   cooldown: 1
  #   inputs:
  #       Tempin: emulator_temperature
  #   entry_condition:
  #       str: 'Tempin > 60'
  #       type: INSTANTANEOUS                       
  #       # reps: 2
  #       # duration: 5                      
  #   exit_condition:
  #       str: 'Tempin <= 40'                   
  #       type: DURATION
  #       duration: 2
  #   # action:
  #   #     type: WRITE
  #   #     sensor: emulator_sloop
  #   #     value: 0
  #   action:
  #     type: WARNING
  #     message: "CRITICAL TEMPERATURE"
  #     suggestion: "Throttle down or safety loop will shut off"
  #     priority: 5
    


PostProcessing: 
  emulator_tsi_drive_state
  emulator_temperature
  emulator_sloop